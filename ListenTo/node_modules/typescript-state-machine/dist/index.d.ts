export declare namespace fsm {
    interface StateMachine<T extends State> {
        readonly state: T;
        onEnterState(state: T, callBack: (from: T, to: T) => void): ListenerRegistration;
        onLeaveState(state: T, callBack: (from: T, to: T) => void): ListenerRegistration;
        onTransition(fromState: T, toState: T, callBack: (from: T, to: T) => void): ListenerRegistration;
        onAnyTransition(callBack: (from: T, to: T) => void): ListenerRegistration;
        waitUntilLeft(state: T): Promise<T>;
        waitUntilEntered(state: T): Promise<T>;
        waitUntilEnteredOneOf(states: [T]): Promise<T>;
    }
    class StateMachineImpl<T extends State> implements StateMachine<T> {
        readonly states: T[];
        readonly validTransitions: Transitions<T>;
        protected _state: T;
        private readonly _transitionListeners;
        protected log: import("log4javascript").Logger;
        constructor(states: T[], validTransitions: Transitions<T>, initialState: T);
        readonly state: T;
        onEnterState(state: T, callBack: (from: T, to: T) => void): ListenerRegistration;
        onLeaveState(state: T, callBack: (from: T, to: T) => void): ListenerRegistration;
        onTransition(fromState: T, toState: T, callBack: (from: T, to: T) => void): ListenerRegistration;
        onAnyTransition(callBack: (from: T, to: T) => void): ListenerRegistration;
        protected addTransitionListener(callBack: (from: T, to: T) => void, fromState?: T, toState?: T): {
            cancel(): void;
        };
        checkInState(state: T, message?: string): void;
        checkInOneOfStates(states: T[], message?: string): void;
        protected inOneOfStates(states: T[]): boolean;
        protected inState(state: T): boolean;
        private invokeAllTransitionListeners;
        private invokeTransitionListeners;
        private transitionLabel;
        waitUntilLeft(state: T): Promise<T>;
        waitUntilEntered(state: T): Promise<T>;
        waitUntilEnteredOneOf(states: T[]): Promise<T>;
        setState(newState: T): void;
        private checkTransition;
        protected canGoToState(newState: T): boolean;
    }
    interface Transitions<T> {
        [stateLabel: string]: T[];
    }
    class State {
        readonly label: string;
        readonly parent?: State | undefined;
        constructor(label: string, parent?: State | undefined);
        toString: () => string;
        userFriendlyDescription(): string;
    }
    interface ListenerRegistration {
        cancel(): void;
    }
    function CheckStateIs(state: State, message?: string): (target: any, propertyKey: string, descriptor: PropertyDescriptor) => PropertyDescriptor;
    function CheckStateIn(states: State[], message?: string): (target: any, propertyKey: string, descriptor: PropertyDescriptor) => PropertyDescriptor;
    function AssumeStateIs(state: State): (target: any, propertyKey: string, descriptor: PropertyDescriptor) => PropertyDescriptor;
    function AssumeStateIsNot(state: State): (target: any, propertyKey: string, descriptor: PropertyDescriptor) => PropertyDescriptor;
}
